Index: pages/TCP 四次挥手.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>- What\n\t- 定义 #card\n\t\t- ![](https://pdai.tech/images/develop/network/dev-network-protocol-x2.png)\n\t\t  （下面的*主动断开方*与*被动断开方*，为客户端与服务端，或者服务端与客户端）\n\t\t- 主动断开方\n\t\t  logseq.order-list-type:: number\n\t\t\t- 发送一个 FIN，用来关闭*主动断开方*到*被动断开方*的数据传送\n\t\t- 被动断开方\n\t\t  logseq.order-list-type:: number\n\t\t\t- 收到这个 FIN，发回一个 ACK，确认序号为收到的 seq+1\n\t\t\t- 和 SYN 一样，一个 FIN 将占用一个序号\n\t\t\t  id:: 6679289b-5527-4b79-bff5-323ce8e47d8e\n\t\t- 被动断开方\n\t\t  logseq.order-list-type:: number\n\t\t\t- 关闭与*主动断开方*的连接，发送一个 FIN 给*主动断开方*\n\t\t- 主动断开方\n\t\t  logseq.order-list-type:: number\n\t\t\t- 发回 ACK 报文确认，并将确认序号设置为收到的 seq+1\n- Why\n\t- 为什么连接的时候是三次握手，关闭的时候却是四次握手 #card\n\t  collapsed:: true\n\t\t- 建立连接时，服务器在 LISTEN 状态下，接收到客户端的 SYN 消息后，会回复 SYN+ACK 消息\n\t\t- 关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了；所以服务器可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接。因此，服务器 ACK 和 FIN 一般都会分开发送，从而导致多了一次\n\t- 为什么客户端最后还要等待 2 MSL？为什么还有一个 TIME_WAIT?\n\t\t- 保证客户端发送的最后一个 ACK 报文能够到达服务器\n\t\t\t- 这个 ACK 报文可能丢失，而服务端已经发送了 ACK 和 FIN 报文请求断开，客户端却没有回应，那么服务端就会重新发送一次\n\t\t\t- 而客户端就能在这 2MSL 时间内收到这个重发的报文，接着给出回应报文，并且会重启 2MSL 计时器\n\t\t- 防止出现类似于“三次握手”中提到的“已经失效的连接请求报文段”\n\t\t\t- 客户端在发送完最后一个确认报文后，等待 2MSL，就可以等到本连接持续的时间内，所产生的所有报文段都从网络中消失\n\t\t\t- 这样新的连接中，就不会出现旧连接的请求报文\n\t\t- 2 MSL，最大报文生存时间\n\t\t\t- 1 MSL = 30 S，2 MSL = 60 S\n\t- 客户端 TIME-WAIT 状态过多的后果和解决办法\n\t\t- 后果\n\t\t- 解决拌饭\n\t\t-\n- How\n- How Good\n- Refs\n- See Also
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pages/TCP 四次挥手.md b/pages/TCP 四次挥手.md
--- a/pages/TCP 四次挥手.md	
+++ b/pages/TCP 四次挥手.md	
@@ -32,7 +32,7 @@
 			- 1 MSL = 30 S，2 MSL = 60 S
 	- 客户端 TIME-WAIT 状态过多的后果和解决办法
 		- 后果
-		- 解决拌饭
+		- 解决办法
 		-
 - How
 - How Good

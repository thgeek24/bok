Index: pages/TCP 四次挥手.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>- What\n\t- 定义 #card\n\t\t- ![](https://pdai.tech/images/develop/network/dev-network-protocol-x2.png)\n\t\t  （下面的*主动断开方*与*被动断开方*，为客户端与服务端，或者服务端与客户端）\n\t\t- 主动断开方\n\t\t  logseq.order-list-type:: number\n\t\t\t- 发送一个 FIN，用来关闭*主动断开方*到*被动断开方*的数据传送\n\t\t- 被动断开方\n\t\t  logseq.order-list-type:: number\n\t\t\t- 收到这个 FIN，发回一个 ACK，确认序号为收到的 seq+1\n\t\t\t- 和 SYN 一样，一个 FIN 将占用一个序号\n\t\t\t  id:: 6679289b-5527-4b79-bff5-323ce8e47d8e\n\t\t- 被动断开方\n\t\t  logseq.order-list-type:: number\n\t\t\t- 关闭与*主动断开方*的连接，发送一个 FIN 给*主动断开方*\n\t\t- 主动断开方\n\t\t  logseq.order-list-type:: number\n\t\t\t- 发回 ACK 报文确认，并将确认序号设置为收到的 seq+1\n- Why\n\t- 为什么连接的时候是三次握手，关闭的时候却是四次握手 #card\n\t  collapsed:: true\n\t\t- 建立连接时，服务器在 LISTEN 状态下，接收到客户端的 SYN 消息后，会回复 SYN+ACK 消息\n\t\t- 关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了；所以服务器可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接。因此，服务器 ACK 和 FIN 一般都会分开发送，从而导致多了一次\n\t- 为什么客户端最后还要等待 2 MSL？为什么还有一个 TIME_WAIT?\n\t\t- 保证客户端发送的最后一个 ACK 报文能够到达服务器\n\t\t\t- 这个 ACK 报文可能丢失，而服务端已经发送了 ACK 和 FIN 报文请求断开，客户端却没有回应，那么服务端就会重新发送一次\n\t\t\t- 而客户端就能在这 2MSL 时间内收到这个重发的报文，接着给出回应报文，并且会重启 2MSL 计时器\n\t\t- 防止出现类似于“三次握手”中提到的“已经失效的连接请求报文段”\n\t\t\t- 客户端在发送完最后一个确认报文后，等待 2MSL，就可以等到本连接持续的时间内，所产生的所有报文段都从网络中消失\n\t\t\t- 这样新的连接中，就不会出现旧连接的请求报文\n\t\t- 2 MSL，最大报文生存时间\n\t\t\t- 1 MSL = 30 S，2 MSL = 60 S\n\t- 客户端 TIME_WAIT 状态过多的后果和解决办法\n\t\t- 后果\n\t\t\t- 作为服务器，短时间内关闭了大量的 Client 连接，就会造成服务器上出现大量的 TIME_WAIT 连接，占据大量的 tuple/tApl，严重消耗服务器的资源，此时部分客户端就会显示连接不上\n\t\t\t- 作为客户端，短时间内大量的[[短连接]]，\n\t\t- 解决办法\n- How\n- How Good\n- Refs\n- See Also
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pages/TCP 四次挥手.md b/pages/TCP 四次挥手.md
--- a/pages/TCP 四次挥手.md	
+++ b/pages/TCP 四次挥手.md	
@@ -31,10 +31,22 @@
 		- 2 MSL，最大报文生存时间
 			- 1 MSL = 30 S，2 MSL = 60 S
 	- 客户端 TIME_WAIT 状态过多的后果和解决办法
+	  collapsed:: true
 		- 后果
 			- 作为服务器，短时间内关闭了大量的 Client 连接，就会造成服务器上出现大量的 TIME_WAIT 连接，占据大量的 tuple/tApl，严重消耗服务器的资源，此时部分客户端就会显示连接不上
-			- 作为客户端，短时间内大量的[[短连接]]，
+			- 作为客户端，短时间内大量的[[短连接]]，会大量消耗 Client 机器的端口，毕竟端口只有 65535 个；端口被耗尽了，后续就无法再发起新的连接
+			- 在高并发短连接的 TCP 服务器上，当服务器处理完请求后立刻主动正常关闭连接，会使大量 socket 处于TIME_WAIT状态；如果客户端的并发量持续很高，此时部分客户端就会显示连接不上
+				- 高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个 0~65535 的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了
 		- 解决办法
+			- 用负载均衡来来抗这些高并发的[[短请求]]
+			- TODO 服务器可以设置[[SO_REUSEADDR]]套接字选项来避免 TIME_WAIT 状态；TIME_WAIT 状态可以通过优化服务器参数得到解决，因为发生 TIME_WAIT 的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的
+			- 强制关闭，发送 RST 包越过 TIME_WAIT 状态，直接进入 CLOSED 状态
+	- 服务器出现了大量 CLOSE_WAIT 状态如何解决
+		- 大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置
+	- 服务端会有一个 TIME_WAIT 状态吗？
+		- 发起连接的主动方基本都是客户端，但是断开连接的主动方服务器和客户端都可以充当，即只要是主动断开连接的一方，就会有 TIME_WAIT 状态
+		- 四次挥手是指断开一个 TCP 连接时，需要客户端和服务端总共发送四个包以确认连接的断开；在 socket 编程中，这一过程由客户端或者服务端任一方执行 close 来触发
+		- 由于 TCP 连接是[[全双工]]的，因此，每个方向的数据传输通道都必须单独进行关闭
 - How
 - How Good
 - Refs

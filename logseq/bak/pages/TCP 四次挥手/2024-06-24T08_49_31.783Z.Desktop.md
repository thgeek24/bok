- What
	- 定义 #card
		- ![](https://pdai.tech/images/develop/network/dev-network-protocol-x2.png)
		  （下面的*主动断开方*与*被动断开方*，为客户端与服务端，或者服务端与客户端）
		- 主动断开方
		  logseq.order-list-type:: number
			- 发送一个 FIN，用来关闭*主动断开方*到*被动断开方*的数据传送
		- 被动断开方
		  logseq.order-list-type:: number
			- 收到这个 FIN，发回一个 ACK，确认序号为收到的 seq+1
			- 和 SYN 一样，一个 FIN 将占用一个序号
			  id:: 6679289b-5527-4b79-bff5-323ce8e47d8e
		- 被动断开方
		  logseq.order-list-type:: number
			- 关闭与*主动断开方*的连接，发送一个 FIN 给*主动断开方*
		- 主动断开方
		  logseq.order-list-type:: number
			- 发回 ACK 报文确认，并将确认序号设置为收到的 seq+1
- Why
	- 为什么连接的时候是三次握手，关闭的时候却是四次握手 #card
	  collapsed:: true
		- 建立连接时，服务器在 LISTEN 状态下，接收到客户端的 SYN 消息后，会回复 SYN+ACK 消息
		- 关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了；所以服务器可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接。因此，服务器 ACK 和 FIN 一般都会分开发送，从而导致多了一次
	- 为什么客户端最后还要等待 2 MSL？为什么还有一个 TIME_WAIT?
		- 保证客户端发送的最后一个 ACK 报文能够到达服务器
			- 这个 ACK 报文可能丢失，而服务端已经发送了 ACK 和 FIN 报文请求断开，客户端却没有回应，那么服务端就会重新发送一次
			- 而客户端就能在这 2MSL 时间内收到这个重发的报文，接着给出回应报文，并且会重启 2MSL 计时器
		- 防止出现类似于“三次握手”中提到的“已经失效的连接请求报文段”
			- 客户端在发送完最后一个确认报文后，等待 2MSL，就可以等到本连接持续的时间内，所产生的所有报文段都从网络中消失
			- 这样新的连接中，就不会出现旧连接的请求报文
		- 2 MSL，最大报文生存时间
			- 1 MSL = 30 S，2 MSL = 60 S
	- 客户端 TIME-WAIT 状态过多的后果和解决办法
		- 后果
		- 解决办法
		-
- How
- How Good
- Refs
- See Also
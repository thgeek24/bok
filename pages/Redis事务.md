- What
	- 一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中
	- 总结
		- Redis事务就是一次、顺序性、排他性的执行一个队列中的一系列命令
- Why
- How
	- 相关命令 #card
	  collapsed:: true
		- `MULTI`
			- 开启事务，Redis会将后续的命令逐个放入队列中，然后使用`EXEC`命令来原子化执行这个命令系列
		- `EXEC`
			- 执行事务中的所有操作命令
		- `DISCARD`
			- 取消事务，放弃执行事务块中的所有命令
		- `WATCH`
			- 监视一个或多下key，如果事务在执行前，这个key（或多个key）被其他命令修改，则事务被中断，不会执行事务中的任何命令
		- `UNWATCH`
			- 取消`WATCH`对所有key的监视
	- 三个阶段
	  collapsed:: true
		- 开启：以`MULTI`开始一个事务
		- 入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面
		- 执行：由`EXEC`命令触发事务
		  
		  当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：
		- 如果客户端发来的是`EXEC`、`DISCARD`、`WATCH`、`MULTI`命令中的其中一个，那么服务器立即执行这个命令
		- 如果客户端发来的是上述四个命令之外的命令，那么服务器并不立即执行这个命令，而是将这个命令放到一个事务队列里，然后向客户端发送`QUEUED`回复
		  ![](https://pdai.tech/images/db/redis/db-redis-trans-1.png)
	- 出现错误时的处理
	  collapsed:: true
		- 语法错误（编译器错误）
		  在开启事务后，修改k1值，但k2语法错误，最终导致事务提交失败，k1、k2保留原值
		  ```sh
		  > set k1 v1
		  "OK"
		  > set k2 v2
		  "OK"
		  > multi
		  "OK"
		  > set k1 11
		  "QUEUED"
		  > sets k2 22
		  "ERR unknown command 'sets', with args beginning with: 'k2' '22' "
		  > exec
		  "EXECABORT Transaction discarded because of previous errors."
		  > get k1
		  "v1"
		  > get k2
		  "v2"
		  ```
		- 类型错误（运行时错误）
		  在开启事务后，修改k1值为11，k2值为22，但将k2的类型作为List，在运行时检测类型错误，最终导致事务提交失败，此时事务并没有回滚，而是跳过错误命令继续执行，结果k1值改变、k2保留原值
		  ```sh
		  > set k1 v1
		  "OK"
		  > set k2 v2
		  "OK"
		  > multi
		  "OK"
		  > set k1 11
		  "QUEUED"
		  > lpush k2 22
		  "QUEUED"
		  > exec
		  1) "OK"
		  2) "ReplyError: WRONGTYPE Operation against a key holding the wrong kind of value"
		  > get k1
		  "11"
		  > get k2
		  "v2"
		  ```
	- WATCH是如何实现监视的
	  collapsed:: true
		- Redis使用`WATCH`命令来决定是继续执行还是回滚，那就需要在`MULTI`之前使用`WATCH`来监控某些键值对，然后使用`MULTI`命令来开启事务，此后对数据结构操作的各种命令进入队列
		- 当使用`EXEC`执行事务时，首先会比对`WATCH`中所监控的键值对，如果没有发生改变，它会执行事务队列中的命令，提交事务；如果发生改变，将不会执行事务中的任何命令，同时事务回滚
		- TODO 无论事务是执行还是回滚，事务结束时，Redis都会取消开启事务前的`WATCH`命令
		- ![](https://pdai.tech/images/db/redis/db-redis-trans-2.png){:height 325, :width 452}
	- 不支持回滚
	  collapsed:: true
		- Redis命令只会因为错误的语法而失败（这种问题不能在入队的时候发现），或者命令用在了类型错误的键上；这些失败的命令是由编程错误造成的，它们应该在开发的过程中被发现，而不应该出现在生产环境中
		- 因为不需要对回滚进行支持，Redis的内部内部可以保持简单而快速
		  有观点认为 Redis 处理事务的做法会产生 bug ， 然而在通常情况下， **回滚并不能解决编程错误带来的问题**。例如，本想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的
	- 对ACID的支持性理解
	  collapsed:: true
		- 原子性atomicity
			- 通过前文可知，Redis事务运行期的错误是不会回滚的，很多文章因此说Redis事务违背原子性的
			- Redis在官方文档中认为，**Redis的事务是原子性的：所有的命令，要么全部执行，要么全部不执行**。而不是完全成功
		- 一致性consistency
			- Redis事务可以保证命令失败的情况下回滚，即数据恢复到没有执行前的样子，是保证一致性的，除非Redis进程意外终结
		- **隔离性Isolation**
			- Redis事务严格遵守隔离性，原因是Redis是单进程单线程模式(v6.0之前），可以保证命令执行过程中不会被其他客户端命令打断
			- 但是，Redis不像其它结构化数据库有隔离级别这种设计
		- **持久性Durability**
			- Redis事务不保证持久性，这是因为Redis持久化策略中的RDB和AOF都是异步执行的，不保证持久性是出于对性能的考虑
	- 其它实现
	  collapsed:: true
		- 基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完
		- 基于中间标记变量，通过另外的标记变量来确认事务是否执行完成，读取数据时先读取该标记变量是否完成。但这样会需要额外写代码实现，比较繁琐
	- Redis 集群的[[主从复制]]
	  collapsed:: true
		- 定义
			- 是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者成为主节点（master），后者成为从节点（slave）；数据的复制是单向的，只能由主节点到从节点
		- 作用
			- 数据冗余：主从复制实现了数据的[[热备份]]，是持久化之外的一种数据冗余方式
			- 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种
			- 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担从节点负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量
			- 高可用基石：主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础
		- 方式
			- 读写分离
				- 读操作：主库、从库都可以接收
				- 写操作：首先到主库执行，然后，主库将写操作同步给从库
				  ![](https://pdai.tech/images/db/redis/db-redis-copy-1.png){:height 233, :width 658}
			- 注意：在 2.8 版本之前只有全量复制，而 2.8 版本后有全量和增量复制
				- 全量（同步）复制：比如第一次同步时
				- 增量（同步）复制：只会把主从库网络断期间主库收到的命令，同步给从库
	- 全量复制的三个阶段
		- ![](https://pdai.tech/images/db/redis/db-redis-copy-2.jpg)
		- 第一阶段：**主从库间建立连接、协商同步的过程**，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库回复确认后，主从库间就可以开始同步了
			- 从库给主库发送 psync 命令，包含两个参数，主库的[[runID]]和复制进度 offset（当从库和主库第一次复制时，由于从库还不知道主库的 runID，此时的 runID 实际为"?"，而 offset 为-1，表示第一次复制）
			- 主库收到后，回复 [[FULLRESYNC]] 命令，包含两个参数，主库的 runID和目前的复制进度 offset
			- 从库收到回复后，会记录下这两个参数
		- 第二阶段：**主库将所有数据同步给库**。从库收到数据后，在本地完成数据加载，这个过程就依赖于内存快照生成的 RDB 文件了
			- 主库执行 bgsave 命令，生成 RDB 文件，然后将文件发给从库
			- 从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据
			- 在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作
		- 第三阶段：**主库会把第二阶段执行过程中新收到的写命令，再发给从库**
			- 当主库完成 RDB 文件的发送后，就会把此时 replication buffer 中的修改操作发给从库
			- 从库再重新执行这些操作。至此，主从库就实现同步了
- How Good
- Refs
- See Also
-
-
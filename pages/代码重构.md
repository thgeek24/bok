- What
- Why
- How
	- 如何去除多余的 if else？
	  collapsed:: true
		- 业务代码中，常常包含这样的逻辑：每中条件下会有不同的处理
		- 例如：两个数 a 和 b 之前可以通过不同的操作符（+，-，*，/）进行计算，初学者通常会这么写
			- ```java
			  public int calculate(int a, int b, String operator) {
			      int result = Integer.MIN_VALUE;
			   
			      if ("add".equals(operator)) {
			          result = a + b;
			      } else if ("multiply".equals(operator)) {
			          result = a * b;
			      } else if ("divide".equals(operator)) {
			          result = a / b;
			      } else if ("subtract".equals(operator)) {
			          result = a - b;
			      }
			      return result;
			  }
			  ```
		- 如何重构
			- 工厂类
			  ```java
			  public class OperatorFactory {
			      static Map<String, Operation> operationMap = new HashMap<>();
			      static {
			          operationMap.put("add", new Addition());
			          operationMap.put("divide", new Division());
			          // more operators
			      }
			   
			      public static Optional<Operation> getOperation(String operator) {
			          return Optional.ofNullable(operationMap.get(operator));
			      }
			  }
			  ```
			- 枚举
			  ```java
			  public enum Operator {
			      ADD {
			          @Override
			          public int apply(int a, int b) {
			              return a + b;
			          }
			      },
			      // other operators
			      
			      public abstract int apply(int a, int b);
			  
			  }
			  ```
			- TODO Command 模式
			  ```java
			  public class AddCommand implements Command {
			      // Instance variables
			   
			      public AddCommand(int a, int b) {
			          this.a = a;
			          this.b = b;
			      }
			   
			      @Override
			      public Integer execute() {
			          return a + b;
			      }
			  }
			  ```
			- 规则引擎
			  collapsed:: true
				- 定义规则
				  ```java
				  public interface Rule {
				      boolean evaluate(Expression expression);
				      Result getResult();
				  }
				  ```
				- Add 规则
				  ```java
				  public class AddRule implements Rule {
				      @Override
				      public boolean evaluate(Expression expression) {
				          boolean evalResult = false;
				          if (expression.getOperator() == Operator.ADD) {
				              this.result = expression.getX() + expression.getY();
				              evalResult = true;
				          }
				          return evalResult;
				      }    
				  }
				  ```
				- 表达式
				  ```java
				  public class Expression {
				      private Integer x;
				      private Integer y;
				      private Operator operator;        
				  }
				  ```
				- 规则引擎
				  ```java
				  public class RuleEngine {
				      private static List<Rule> rules = new ArrayList<>();
				   
				      static {
				          rules.add(new AddRule());
				      }
				   
				      public Result process(Expression expression) {
				          Rule rule = rules
				            .stream()
				            .filter(r -> r.evaluate(expression))
				            .findFirst()
				            .orElseThrow(() -> new IllegalArgumentException("Expression does not matches any Rule"));
				          return rule.getResult();
				      }
				  }
				  ```
			- 策略模式
				- 操作
				  ```java
				  public interface Opt {
				      int apply(int a, int b);
				  }
				  
				  @Component(value = "addOpt")
				  public class AddOpt implements Opt {
				      @Autowired
				      xxxAddResource resource; // 这里通过Spring框架注入了资源
				  
				      @Override
				      public int apply(int a, int b) {
				         return resource.process(a, b);
				      }
				  }
				  
				  @Component(value = "devideOpt")
				  public class devideOpt implements Opt {
				      @Autowired
				      xxxDivResource resource; // 这里通过Spring框架注入了资源
				  
				      @Override
				      public int apply(int a, int b) {
				         return resource.process(a, b);
				      }
				  }
				  ```
				- 策略
				  ```java
				  @Component
				  public class OptStrategyContext{
				   
				  
				      private Map<String, Opt> strategyMap = new ConcurrentHashMap<>();
				   
				      @Autowired
				      public OptStrategyContext(Map<String, TalkService> strategyMap) {
				          this.strategyMap.clear();
				          this.strategyMap.putAll(strategyMap);
				      }
				   
				      public int apply(Sting opt, int a, int b) {
				          return strategyMap.get(opt).apply(a, b);
				      }
				  }
				  ```
	- 如何去除不必要的 != 判空？
		- 空对象模式
		  ```java
		  public class MyParser implements Parser {
		    private static Action NO_ACTION = new Action() {
		      public void doSomething() { /* do nothing */ }
		    };
		  
		    public Action findAction(String userInput) {
		      // ...
		      if ( /* we can't find any actions */ ) {
		        return NO_ACTION;
		      }
		    }
		  }
		  ```
		  然后便可以如下调用
		  ```java
		  ParserFactory.getParser().findAction(someInput).doSomething();
		  ```
		- Java 8 及之后使用 Optional
		  ```java
		  Optional.of(new Outer())
		      .map(Outer::getNested)
		      .map(Nested::getInner)
		      .map(Inner::getFoo)
		      .ifPresent(System.out::println);Outer outer = new Outer();
		  if (outer != null && outer.nested != null && outer.nested.inner != null) {
		      System.out.println(outer.nested.inner.foo);
		  }
		  ```
		  我们可以通过利用 Java 8 的 Optional 类型来摆脱所有这些 null 检查。map 方法接收一个 Function 类型的 lambda 表达式，并自动将每个 function 的结果包装成一个 Optional 对象。这使我们能够在一行中进行多个 map 操作。Null 检查是在底层自动处理的
		- Java 8 及之后使用 Optional
		  ```java
		  Optional.of(new Outer())
		      .map(Outer::getNested)
		      .map(Nested::getInner)
		      .map(Inner::getFoo)
		      .ifPresent(System.out::println);Outer outer = new Outer();
		  if (outer != null && outer.nested != null && outer.nested.inner != null) {
		      System.out.println(outer.nested.inner.foo);
		  }
		  ```
		  我们可以通过利用 Java 8 的 Optional 类型来摆脱所有这些 null 检查。map 方法接收一个 Function 类型的 lambda 表达式，并自动将每个 function 的结果包装成一个 Optional 对象。这使我们能够在一行中进行多个 map 操作。Null 检查是在底层自动处理的
		  ```java
		  Optional.of(new Outer())
		      .map(Outer::getNested)
		      .map(Nested::getInner)
		      .map(Inner::getFoo)
		      .ifPresent(System.out::println);
		  ```
		  还可以通过 supplier 函数来解决嵌套的问题
		  ```java
		  Outer obj = new Outer();
		  resolve(() -> obj.getNested().getInner().getFoo())
		      .ifPresent(System.out::println);
		  ```
- How Good
- Refs
- See Also
-
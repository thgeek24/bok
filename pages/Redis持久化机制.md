- What
	- [[RDB]]持久化：把当前进程数生成快照保存到磁盘
		- 缺点：不适合**实时**持久化
			- 应对方案： [[AOF]]持久化
	- [[AOF]]持久化：“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些是以文本形式保存
	- Redis 4.0 中提出了一个混合使用AOF日志和内存快照的方法：内存快照以一定的频率进行，两次内存快照间用AOF日志记录这期间的所有命令操作
		- 优点：
			- 快照不用很频繁地进行，避免了fork对主线程的影响
			  logseq.order-list-type:: number
			- AOF日志也只记录两次快照间的操作，而不用记录所有的操作，因此就不会出现文件过大的情况了，也可以避免重写开销
			  logseq.order-list-type:: number
		- ![](https://pdai.tech/images/db/redis/redis-x-rdb-4.jpg){:height 289, :width 452}
		  如图所示，T1时刻和T2时刻的修改，用AOF日志记录，等第二次做全量快照时，就可以亲空AOF日志了，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。
		  
		  这样既能享受到[[RDB]]文件快速恢复的好处，又能享受到[[AOF]]只记录操作命令的简单优势，实际环境中用的很多
		- 可以每秒做一次RDB快照吗
			- 仅用RDB快照，在两次快照间，如果发生了机器宕机，则可能出现数据丢失
			  
			  如下图所示，在T0和T0+t时刻进行两次快照，如果在这期间发生宕机，恢复时，只有T0时刻的快照可用，那么对数据块5和9的修改就会丢失
			  https://pdai.tech/images/db/redis/redis-x-rdb-2.jpg
			- 即使bgsave执行时不会阻塞主线程，但频繁地进行全量快照，会造成两个方面的开销：
				- 消耗磁盘带宽
				- fork出子进程时，会阻塞主线程
			- 应对办法
				- 做了一次全量快照后，后续的快照只记录修改的数据
				- 但这会需要我们使用额外的元数据信息去记录哪些数据被修改了，这样便带来了额外的空间开销问题。那么怎么才能既用到RDB的快速恢复，又能以最小的开销实现数据不丢失呢？
					- RDB和[[AOF]]混合的方式
- Why
- How
- How Good
- Refs
- See Also
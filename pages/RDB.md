- What
	- Redis Database，一种Redis持久化的机制，恢复文件很快，但可能会出现数据丢失
- Why
- How
	- 触发方式
		- 手动触发
			- save命令
				- 阻塞当前Redis服务器，直到RDB过程完成为止
				- 对内存比较大的实例会造成长时间阻塞，线上环境不建议使用
			- bgsave命令
				- Redis进程执行fork操作创建子进程，Redis持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短
				- 流程图
				  ![](https://pdai.tech/images/db/redis/redis-x-rdb-1.png){:height 446, :width 392}
		- 自动触发
			- redis.conf 配置 `save m n`，表示当m秒内有n次修改时，则自动触发bgsave生成RDB文件
			- 主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点
			- 执行debug reload命令重新加载redis时也会触发bgsave操作
			- 默认情况下执行shutdown命令时，如果没有开[[AOF]]持久化，那么也会触发bgsave操作
	- 如何保证[[数据一致性]]
		- RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域
		- 举个例子：如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据
		  ![](https://pdai.tech/images/db/redis/redis-x-aof-42.jpg){:height 262, :width 452}
		- 如果发生服务崩溃怎么办
			- 在没有将数据全部写入到磁盘前，这次快照操作都不算成功。如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份
- How Good
- Refs
- See Also
- Why
- What
	- 常见的算法思想
	  collapsed:: true
		- **分治算法**
			- 基本思想：将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解
		- **动态规划算法**
			- 通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。和分治算法最大的差别：适用于动态规划算法求解的问题经过分解后得到的子问题往往不是相互独立的，而是下一个子阶段的求解是建立在上一个子阶段的解的基础上的
		- **贪心算法**
			- 保证每次操作都是局部最优的，并且最后得到的结果是全局最优的
		- **二分法**
			- 比如重要的二分法，比如二分查找；二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列
		- **搜索算法**
			- 主要包含BFS，DFS
		- **Backtracking(回溯)**
			- 属于 DFS, 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法
	- 常见的排序算法
	  collapsed:: true
		- 在综合复杂度及稳定性情况下，通常**希尔, 快排和 归并**需要重点掌握
		- ![](https://pdai.tech/images/alg/alg-sort-overview-1.png){:height 270, :width 452}
		- **冒泡排序**(Bubble Sort)
		- **快速排序**(Quick Sort)
		- **插入排序**(Insertion Sort)
		- **Shell排序**(Shell Sort)
		- **选择排序**(Selection sort)
		- **堆排序**(Heap Sort)
		- **归并排序**(Merge Sort)
		- **桶排序**(Bucket Sort)
		- **基数排序**(Radix Sort)
	- [[加密算法]]
- How
	- **大数据处理算法**
		- [[海量数据的处理]]
		- [[分治思想]]
		- [[海量日志数据，提取出某日访问百度次数最多的那个IP?]]
		- [[寻找热门查询，300万个查询字符串中统计最热门的10个查询?]]
		- [[有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词?]]
		- [[海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10?]]
		- [[有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序?]]
		- [[给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url?]]
		- [[怎么在海量数据中找出重复次数最多的一个?]]
		- [[上千万或上亿数据(有重复)，统计其中出现次数最多的前N个数据?]]
		- [[一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析?]]
		- [[一个文本文件，找出前10个经常出现的词，但这次文件比较长，说是上亿行或十亿行，总之无法一次读入内存，问最优解?]]
		- **100w个数中找出最大的100个数?**
			- 方案一
				- 采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)
			- 方案二
				- 采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)
			- 方案三
				- 在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)
		- 5亿个int找它们的中位数?
			- **思路一**
				- 这个例子比上面那个更明显。首先我们将int划分为2^16个区域，然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。然后第二次扫描我们只统计落在这个区域中的那些数就可以了。
				  
				  实际上，如果不是int是int64，我们可以经过3次这样的划分即可降低到可以接受的程度。即可以先将int64分成224个区域，然后确定区域的第几大数，在将该区域分成220个子区域，然后确定是子区域的第几大数，然后子区域里的数的个数只有2^20，就可以直接利用direct addr table进行统计了。
			- **思路二**
				- 同样需要做两遍统计，如果数据存在硬盘上，就需要读取2次。
				  
				  方法同基数排序有些像，开一个大小为65536的Int数组，第一遍读取，统计Int32的高16位的情况[[计算机存储数字时的高位和低位]]，也就是0-65535，都算作0,65536 - 131071都算作1。就相当于用该数除以65536($2^{16}$)。Int32 除以 65536的结果不会超过65536种情况，因此开一个长度为65536的数组计数就可以。每读取一个数，数组中对应的计数+1，考虑有负数的情况，需要将结果加32768后，记录在相应的数组内
				  
				  第一遍统计之后，遍历数组，逐个累加统计，看中位数处于哪个区间，比如处于区间k，那么0- k-1的区间里数字的数量sum应该`<n/2`(2.5亿)。而k+1 - 65535的计数和也`<n/2`，第二遍统计同上面的方法类似，但这次只统计处于区间k的情况，也就是说(x / 65536) + 32768 = k。统计只统计低16位的情况。并且利用刚才统计的sum，比如sum = 2.49亿，那么现在就是要在低16位里面找100万个数(2.5亿-2.49亿)。这次计数之后，再统计一下，看中位数所处的区间，最后将高位和低位组合一下就是结果了
		- 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数
			- 方案一
				- 采用[[2-Bitmap]](每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义)进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可
			- 方案二
				- 也可采用分治，划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素
		- 给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中?
			- 用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在
- How Good
- Refs
	- [Java 全栈知识体系：常见排序算法](https://pdai.tech/md/interview/x-interview.html#_7-2-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3)
- See Also
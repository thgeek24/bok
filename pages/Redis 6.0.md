- What
- Why
- How
	- TODO 6.0 之前如何提高多核 CPU 的利用率
	  collapsed:: true
		- 可以在同一个服务器部署多个Redis的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个CPU，你可以考虑一下分片（shard）
	- 6.0 之前的版本真的是单线程的吗
	  collapsed:: true
		- Redis 在处理客户端请求时，包括获取（socket 读）、解析、执行、内容返回（socket 写）等，都是由一个顺序串行的主线程执行的，即单线程
		- Redis 4.0 之后除了主线程之外，还有后台线程在处理一些较为缓慢的操作，比如脏数据的清理，无用链接的释放，大 key 的删除，数据持久化 bgsave、bgrewriteaof 等，都是在主线程之外的线程单独执行的
	- 6.0 之前为什么一直不用多线程
	  collapsed:: true
		- 官方回复
			- 使用 Redis 时，几乎不存在 CPU 成为瓶颈的情况，Redis 主要受限于内存和网络。例如在一个普通的 Linux 系统上，Redis 可以通过 pipelining 每秒处理 100 完个请求，所以如果程序主要使用 O(N) 和 O(log(N)) 的命令，它几乎不会占用太多 CPU
		- 使用了单线程后，可维护性高
			- 多线程的弊端
				- 引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度
				- 可能存在线程切换，甚至加锁解锁、死锁造成的性能损耗
			- Redis 通过[[AE 事件模型]]和[[IO 多路复用技术]]，处理性能非常高，因此没必要使用多线程。单线程机制使得 Redis 内部实现的复杂度大大降低，Hash 的[[惰性 Rehash，Lpush]]等等“线程不安全”的命令都可以无锁进行
	- 6.0 为什么要引入多线程
		- Redis 将所有数据放在内存中，内存的响应事件大约为 100 纳秒，对于小数据包，Redis 服务器可以处理 80,000 到 100,000 QPS，这也是 Redis 处理的极限了，这样的单线程 Redis 已满足大多数业务需求
		- 随着越来越复杂的业务场景，动不动上亿的交易量，因此需要更大的 QPS
			- 常见的解决方案
				- 在分布式架构中对数据进行分区并采用多个服务器
			- 该方案的缺点
				- 要管理的 Redis 服务器太多，维护代价大
				- 某些适用于单个 Redis 服务器的命令不适用于数据分区
				- 数据分区无法解决热点读/写问题
				- 数据偏斜，重新分配和放大/缩小变得更加复杂
		- 从 Redis 自身角度来说，因为读写网络的 read/write 系统调用占用了 Redis 执行期间大部分 CPU 时间，瓶颈主要在于网络的 IO 消耗，因此主要有两个优化方向
			- 提高网络 IO 性能
			  logseq.order-list-type:: number
				- 使用 DPDK 来替代内核网络栈的方式
			- 使用多线程充分利用多核
			  logseq.order-list-type:: number
				- Memcached
		- 协议栈优化的方式跟 Redis 关系不大，而支持多线程是一种最有效最便捷的操作方式。因此，Redis 6.0 之后支持多线程，主要有两个原因
			- 充分利用服务器 CPU 资源，之前主线程只能利用一个核
			  logseq.order-list-type:: number
			- 多线程可以分摊 Redis 同步 IO 读写负荷
			  logseq.order-list-type:: number
	- 6.0 是否默认开启了多线程
		- 默认是禁用，只是用主线程
		- 如需开启，修改配置文件 redis.conf：
			- io-threads-do-reads yes
			- io-threads 4
			  io-threads 需设置为大于 1 的数（比如这里设置为 4），否则实际仍为单线程
	- 6.0 多线程开启时，线程数如何设置
		- 官方建议
			- |CPU核数|建议线程数|
			  |4|2 或 3|
			  |8|6|
			  线程数一定要小于机器核数
			- 线程数并不是越大越好，官方认为超过 8 个基本没有什么意义
	- 6.0 多线程的实现机制
		- 核心思路
			- 将主线程的 IO 读写任务拆分出来，给一组独立的线程去执行，使得多个 socket 的读写可以并行化
		- 步骤
			- 主线程负责接收建立连接的请求，获取 socket 放到全局等待处理
			- 主线程处理完读事件之后，通过 Round Robin 将这些连接分配给 IO 线程（并不会等待队列满）
			- 主线程阻塞等待 IO 线程读取 socket 完毕
			- TODO (请求数据读取怎么理解？)主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行
			- 主线程阻塞等待 IO 线程将数据会写 socket 完毕
			- 解除绑定，清空等待队列
		- IO 线程特点
			- 要么同时在读 socket，要么同时在写，不会同时读和写
			- 只负责读写 socket 解析命令，不负责命令处理（主线程串行执行命令）
	- 开启多线程后，线程并发安全问题
		- Redis 的多线程部分只用来处理网络数据的读写和协议解析，执行命令还是由单线程顺序执行，因此不存在线程的并发安全问题
- How Good
- Refs
- See Also
- What
	- Redis 集群的[[主从复制]]
	  collapsed:: true
		- 定义
			- 是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者成为主节点（master），后者成为从节点（slave）；数据的复制是单向的，只能由主节点到从节点
		- 作用
			- 数据冗余：主从复制实现了数据的[[热备份]]，是持久化之外的一种数据冗余方式
			- 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种
			- 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担从节点负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量
			- 高可用基石：主从复制还是哨兵和集群能够实施的基础，因此说主从复制是 Redis 高可用的基础
		- 方式
			- 读写分离
				- 读操作：主库、从库都可以接收
				- 写操作：首先到主库执行，然后，主库将写操作同步给从库
				  ![](https://pdai.tech/images/db/redis/db-redis-copy-1.png){:height 233, :width 658}
			- 注意：在 2.8 版本之前只有全量复制，而 2.8 版本后有全量和增量复制
				- 全量（同步）复制：比如第一次同步时
				- 增量（同步）复制：只会把主从库网络断期间主库收到的命令，同步给从库
	- [[Redis 增量复制]]
	- [[Redis 无磁盘复制模式]]
- Why
- How
	- 全量复制的三个阶段
	  collapsed:: true
		- ![](https://pdai.tech/images/db/redis/db-redis-copy-2.jpg)
		- 第一阶段：**主从库间建立连接、协商同步的过程**，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库回复确认后，主从库间就可以开始同步了
			- 从库给主库发送 psync 命令，包含两个参数，主库的[[runID]]和复制进度 offset（当从库和主库第一次复制时，由于从库还不知道主库的 runID，此时的 runID 实际为"?"，而 offset 为-1，表示第一次复制）
			- 主库收到后，回复 [[FULLRESYNC]] 命令，包含两个参数，主库的 runID和目前的复制进度 offset
			- 从库收到回复后，会记录下这两个参数
		- 第二阶段：**主库将所有数据同步给库**。从库收到数据后，在本地完成数据加载，这个过程就依赖于内存快照生成的 RDB 文件了
			- 主库执行 bgsave 命令，生成 RDB 文件，然后将文件发给从库
			- 从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据
			- 在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作
		- 第三阶段：**主库会把第二阶段执行过程中新收到的写命令，再发给从库**
			- 当主库完成 RDB 文件的发送后，就会把此时 replication buffer 中的修改操作发给从库
			- 从库再重新执行这些操作。至此，主从库就实现同步了
	- 不持久化的主服务器自动重启为什么危险
	  collapsed:: true
		- 设置节点 A 为主服务器并关闭持久化；节点 B 和 C 从节点 A 复制数据
		- 这时出现了一个崩溃，但Redis具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集
		- 节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除
		- 当在高可用系统中使用 Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。比如主服务器可能在很短的时间就完成了重启，以至于 Sentinel 都无法检测到这次失败，那么上面说的这种失败的情况就发生了
		  如果数据比较重要，且主从复制的主服务器持久化功能也被关闭，那么应该禁止实例自动重启
	- 为什么不是用 RDB 而不是用 AOF
	  collapsed:: true
		- RDB 文件内容是经过压缩的二进制文件（不同类型数据做了针对性优化），文件很小；而 AOF 文件记录了每一次写操作的命令，写操作越多文件越大，其中还包括对同一 key 的多次冗余操作
			- 主从全量数据同步时，传输 RDB 文件可以尽量降低对主库机器网络带宽的消耗
			- 从库在加载 RDB 文件时：
				- 文件小，读取整个文件的速度会很快
				- RDB 文件存储的都是二进制数据，从库直接按照 RDB 协议解析还原数据即可，速度非常快；而 AOF 需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比 RDB 会慢得多
		- 如果要使用 AOF 功能，就必须打开 AOF 功能，打开 AOF 就要选择文件刷盘的策略，选择不当会严重影响Redis性能；RDB 只有在需要定时备份和主从全量复制数据时才会触发生成一次快照，而在很多丢失数据不敏感的业务场景，其实是不需要开启 AOF 的
	- 从库的从库
		- 一次全量复制中，对于主库而言，需要完成两个耗时的操作：**生成 RDB 文件和传输 RDB 文件**
		- 如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量复制。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力
		- 为解决这个问题，就采用了“主-从-从”模式，**将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上**
			- 在部署主从集群的时候，可以手动选择一个从库（比如内存资源配置较高的从库），用于级联其他从库
			- 然后选择一些从库（比如三分之一的从库），在这些从库上执行如下命令，让它们和刚才选的从库建立起主从关系
			  ```sh
			  replicaof 所选从库的ip 6379
			  ```
			- 这样这些从库在同步时，就不会和主库进行交互了，而只和级联的从库同步写操作，于是便减轻了主库的压力
			  ![](https://pdai.tech/images/db/redis/db-redis-copy-4.jpg)
			- 一旦主从库完成了全量复制，它们之间便会一直维护一个网络连接，主库会通过它将后续的命令操作再同步给从库，这个过程也称为[[基于长连接的命令传播]]，可以避免频繁建立连接的开销
- How Good
- Refs
- See Also
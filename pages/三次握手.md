- What
	- 流程
		- ![](https://pdai.tech/images/develop/network/dev-network-protocol-x1.png)
		- 发送端首先发送一个带 SYN 标志的数据包给接收方（第一次的seq 序列号是随机产生的，这样是为了网络安全，否则黑客容易获取到你与其他主机之间的初始化序列号，并且伪造序列号进行攻击）
		  logseq.order-list-type:: number
		- 接收端收到后，回传一个带有 SYN/ACK（acknowledgement）标志的数据包以示传达确认信息（SYN 是为了告诉发送端，发送方到接收方的通道没问题；ACK 用来验证接收方到发送方的通道没问题）
		- 最后，发送端再回传一个带 ACK 标志的数据包，代表握手结束（若在某个过程中莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包）
- Why
	- 目的
		- 建立可靠的[[通信]]信道，双方确认自己和对方的发送与接收是正常的
		  |握手|发送端（client）|接收端（server）|
		  |第一次|什么都确认不了|对方发送正常，自己接收正常|
		  |第二次|对方发送、接收正常，自己发送、接收正常|对方发送正常，自己接收正常|
		  |第三次|对方发送、接收正常，自己发送、接收正常|对方发送、接收正常，自己发送、接收正常|
	- 两次握手为什么不行？为什么 TCP 客户端最后还要发送一次确认？
		- 目的
			- 防止已经失效的链接请求报文又突然传送到了服务器
		- 错误场景
			- 客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留太长时间了
		- 详细分析
			- 由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接
			- 此时此前滞留的那一次请求连接，网络通畅后到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费
			- 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接
	- 为什么三次握手时，返回时 ack 值是 seq + 1
		- 假设对方接收到数据，比如 sequence number = 1000，TCP Payload = 1000，数据第一个字节编号为 1000，最后一个为 1999；回复一个确认报文，确认号为 2000，意味着编号 2000 前的字节接收完成，准备接收编号为 2000 以及更多的数据
		- 确认收到的序列，并且告诉发送端下一次发送的序列号从哪里开始（便于接收方对数据排序，便于选择重传）
	- TCP 三次握手中，最后一次回复丢失，会发生什么
		- 如果最后一次 ACK 在网络中丢失，那么 Server（服务端）的 TCP 连接的状态仍为 SYN_RECV，并且根据 TCP 的超时重传机制依次等待 3 秒、6 秒、12 秒后重新发送 SYN+ACK 包，以便 Client（客户端）重新发送 ACK 包
		- 如果重发指定次数后，仍然未收到 ACK 应答，那么一段时间后，Server（服务端）自动关闭这个连接
		- 但是 Client（客户端）认为这个连接已经建立，如果 Client（客户端）向 Server（服务端）发送数据，Server（服务端）将以 RST 包（Reset，标示复位，用于异常的关闭连接）响应，此时，客户端知道第三次握手失败
- How
- How Good
- Refs
- See Also
-